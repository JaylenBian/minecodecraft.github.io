<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[再探OC对象模型(isa/superclass)--从NSObject的实现出发]]></title>
    <url>%2F2018%2F01%2F09%2F%E5%86%8D%E6%8E%A2OC%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B(isa%3Asuperclass)--%E4%BB%8ENSObject%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%87%BA%E5%8F%91%2F</url>
    <content type="text"><![CDATA[了解Objective-C中类型结构后，我们知道了OC的对象模型构成。在此讨论提出一个问题：object_getClass(obj)与[obj class]有何区别？ 下面，我们将从isKindOfClass和isMemberOfClass两个方法入手进行探究。 背景Objective-C中对于类的数据结构，分为了实例(object)、类(class)、元类(meta class)、根元类(root meta class)几种(也可加上根类(root class))。在他们的层次结构中，isa扮演者指向其父类型的职责。具体见这张经典的图: Runtime中为我们提供了object_getClass()函数，而NSObject为我们提供了+/- (Class)class两种方法。那么，这两种函数是否相同呢？我们来使用isKindOfClass和isMemberOfClass验证: 12345NSObject *obj = [[NSObject alloc] init];NSLog(@&quot;%p&quot;, obj);NSLog(@&quot;%p&quot;, object_getClass(obj));NSLog(@&quot;%p&quot;, object_getClass([NSObject class]));NSLog(@&quot;%p&quot;, [NSObject class]); 打印如下 12340x10053a440 // [[NSObject alloc] init]0x7fffaa313140 // object_getClass(obj)0x7fffaa3130f0 // object_getClass([NSObject class])0x7fffaa313140 // [NSObject class] 可以看到，object_getClass(obj)与[NSObject class]是同一地址，说明对实例调用object_getClass获取了其类()，而对其类调用class类方法也是获取其类(这个”类”是指Runtime对象模型中的”类”)。 就这样就结束探究了吗，当然不会，下面的代码结果如何呢？ 12345BOOL test1 = [[NSObject class] isKindOfClass:[NSObject class]];BOOL test2 = [[NSObject class] isMemberOfClass:[NSObject class]];BOOL test3 = [[SubClass class] isKindOfClass:[SubClass class]];BOOL test4 = [[SubClass class] isMemberOfClass:[SubClass class]];BOOL test5 = [[SubClass class] isSubclassOfClass:object_getClass([NSObject class])]; 如果认为全为YES，那么这篇文章就有必要一看了。(不认为的话也有必要看看;P)实际结果为: 仅第一个为YES，其余全为NO。为什么会这样呢？NSObject难道不是NSObject吗?SubClass明明继承了NSObject为什么又不是它的子类呢? 探究NSObject的实现探究这个问题，我们首先从方法的实现入手，苹果开源了Runtime源码，所以我们可以查看NSObject的实现: 12345678910111213141516171819202122232425262728293031323334353637// class方法+ (Class)class &#123; return self;&#125;- (Class)class &#123; return object_getClass(self);&#125;// isMemberOfClass方法+ (BOOL)isMemberOfClass:(Class)cls &#123; return object_getClass((id)self) == cls;&#125;- (BOOL)isMemberOfClass:(Class)cls &#123; return [self class] == cls;&#125;// isKindOfClass方法+ (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = object_getClass((id)self); tcls; tcls = class_getSuperclass(tcls)) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;- (BOOL)isKindOfClass:(Class)cls &#123; for (Class tcls = [self class]; tcls; tcls = class_getSuperclass(tcls)) &#123; if (tcls == cls) return YES; &#125; return NO;&#125;// isSubclassOfClass方法+ (BOOL)isSubclassOfClass:(Class)cls &#123; for (Class tcls = self; tcls; tcls = class_getSuperclass(tcls)) &#123; if (tcls == cls) return YES; &#125; return NO;&#125; 我们可以发现，NSObject的class方法实际提供了类方法和实例方法两种，而前者直接返回类，后者调用了object_getClass，也就是说class只会返回实例或对象对应的类(这个”类”是指Runtime对象模型中的”类”)。那么，从上面用代码结果不全为YES，则可以判断出object_getClass不是仅仅向class方法一样返回当前类这么简单(即使文档只写了这一特性)。 探究object_getClass()现在我们来探究object_getClass的具体过程，在Runtime的类模型中，isa连接了几种类的结构，所以推断object_getClass是通过获取isa不断向上寻找的，所以出现了上面class方法与object_getClass方法的结果不一致的问题。我们来编写一下代码测试: 1234BOOL getObj1 = object_getClass([NSObject class]) == object_getClass(object_getClass([NSObject class]));BOOL getObj2 = object_getClass([SubClass class]) == object_getClass(object_getClass(object_getClass([SubClass class])));BOOL getObj3 = object_getClass([NSObject class]) == class_getSuperclass(object_getClass([NSObject class]));BOOL getObj4 = object_getClass([NSObject class]) == object_getClass(class_getSuperclass(object_getClass([NSObject class]))); 对于以上代码，如果我们的推测是正确的: object_getClass为按照isa遍历，class_getSuperclass为按照superclass遍历。那么按照上面所示的模型图，结果应该是(YES,NO,NO,YES)。 结果果然如此，这说明: object_getClass为按照isa遍历，class_getSuperclass为按照superclass遍历。 那么我们刚才的代码在等号右侧显然是进行了如下过程:getObj1: Root Class -&gt; Meta Root Class -&gt; Meta Root ClassgetObj2: Class -&gt; Meta Class -&gt; Meta Root Class -&gt; Meta Root ClassgetObj3: Root Class -&gt; Meta Root Class -&gt; Root ClassgetObj4: Root Class -&gt; Meta Root Class -&gt; Root Class -&gt; Meta Root Class 这说明了这两个函数的遍历顺序，也加深了我们对于isa、superclass指针在OC对象模型的理解:比如子类通过isa会获取其元类，而通过元类isa直接获取到根元类，而非层层向上遍历。 问题解析现在我们在回过头看刚才isKindOfClass和isMemberOfClass方法，就不难明白第一个试验中仅第一个为YES的原因了: 类或实例调用class方法只会获取该”类”,object_getClass会沿着isa链持续遍历，而isKindOfClass和isMemberOfClass的类方法正是采用了后者来遍历，所以返回的值。 其实说白了，文档没有告诉我们isKindOfClass和isMemberOfClass还有类方法，而它的类方法是持续向上级遍历的，实例方法则只是判断其”类”的。如下代码，使用实例方法结果是正确。 12345// 类方法 结果为NOBOOL testOfCls = [[NSObject class] isMemberOfClass:[NSObject class]];// 实例方法 结果为YESNSObject *obj = [[NSObject alloc] init];BOOL testOfObj = [obj isMemberOfClass:[NSObject class]]; 总结通过这一过程，我们加深了对Runtime对象模型层级的理解。同时，也总结一下class、isKindOfClass和isMemberOfClass方法各自的处理机制(以下加双引号的类指Runtime对象结构中的”类”概念): class方法 类方法: 返回该”类”。 实例方法: 返回对象对应的”类”。 isKindOfClass方法 类方法: 沿isa链向上遍历，判断是否与参数的isa链上任意层级的个体相同。 实例方法: 判断是否与参数对应的”类”相同。 isMemberOfClass 类方法: 判断该类的”元类”是否与参数相同。 实例方法: 判断该实例的”类”是否与参数相同。 可以看出，类方法的处理机制并非字面理解的同级比较，也自然会出现[NSObject class] isMemberOfClass:[NSObject class]不对的问题。在使用时要特别注意，在理解OC对象模型的基础上使用。 相关资料 Apple OpenSource - NSObject.mm]]></content>
      <categories>
        <category>iOS技术</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
        <tag>Objective-C</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[操作系统的进程/线程同步问题]]></title>
    <url>%2F2018%2F01%2F06%2F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%9B%E7%A8%8B%3A%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[很多操作系统都提供了进程和线程的并发操作，他们可能在异步执行时访问共享数据，而并发访问共享数据可能带来数据不一致的同步问题，在此总结一下操作系统的进程/线程同步问题，以线程的并发为例。 问题简介 上图是多线程的状态(以iOS系统为例)。操作系统是通过CPU的时间片轮转来实现多线程的，每个线程有着对应的时间片，当其时间片到来时CPU会切换到该线程上下文并执行，待时间片结束后切换至下一线程，保存原线程的上下文并加载下一线程的上下文，依次循环。 但是，CPU何时切换并不是由用户决定，当时间片到达后会立即进行线程的切换，那么当多个线程并发进行读写操作时，就可能出现线程同步问题。 我们先重现一下这个问题，以下函数模拟了买票的操作，持续买票直到卖完，整型sum表示当前的票数，函数如下:1234567891011- (void)buyFunction &#123; // 有余票则继续购买 while (sum &gt; 0) &#123; // 购买前打印当前票数 NSLog(@&quot;线程%@准备买票 剩余:%d张票&quot;, [NSThread currentThread].name, sum); // 模拟购买操作,票数-1 sum--; &#125; // 票卖完则打印当前票数 NSLog(@&quot;线程%@: 票已卖完 剩余:%d张票&quot;, [NSThread currentThread].name, sum);&#125; 现在我们开两个线程同时执行此操作，初始为10张票(sum = 10)，查看控制台输出:12345678910111213线程2准备买票 剩余:10张票线程1准备买票 剩余:10张票线程1准备买票 剩余:9张票线程2准备买票 剩余:8张票线程1准备买票 剩余:7张票线程2准备买票 剩余:6张票线程1准备买票 剩余:5张票线程2准备买票 剩余:4张票线程1准备买票 剩余:3张票线程2准备买票 剩余:2张票线程1准备买票 剩余:1张票线程2: 票已卖完 剩余:0张票线程1: 票已卖完 剩余:-1张票 观察结果，我们发现了一些问题:(1) 两次买票过程余票数相同(2) 同一张票买了两次(3) 没有余票之后仍然被买了一次 这样的结果已经体现出了线程不安全的危害，为什么会出现这种情况呢？前面讲到，CPU会在时间片结束后保存当前线程上下文，并切换至下一线程。那么当前线程很可能在获取了数据还没来得及处理，时间片就已结束，而当该线程的下一时间片到来时，数据可能已经变化了。一种可能的过程如下图所示 这便是进程/线程并发访问数据时会存在的同步问题，接下来我们讨论如何解决该问题。 临界区问题为了并发访问数据的同步问题，我们介绍临界区的概念。 临界区: 一种代码段，在其中可能发生多个线程共同改变变量、读写文件等操作，其要求当一个线程进入临界区时，其他线程不能进入。从而避免出现同时读写的问题。(实际上，临界区只需保证可以有多个读者同时执行读取操作，或唯一写者执行写入操作)进入区: 判断线程能否进入临界区的代码段。退出区: 线程离开临界区后可能对其执行的某些操作。剩余区: 线程完全退出临界区和退出区后的剩下全部代码。 对于上述的买票示例，买票的整个过程即为临界区代码，但我们缺失了进入区，无法保证临界区内线程的唯一，所以出现了同步问题。 临界区调度原则所有临界区调度应当符合以下原则: 同一时间临界区内仅可有一个线程执行，如果有若干线程请求进入空闲临界区，一次进允许一个线程进入，如果临界区已有线程，则要求其他视图进入临界区的线程等待。 进入临界区的线程必须在有限时间内退出，以保证其他线程能进入该临界区。 如果线程不能进入临界区，应让出CPU，避免出现忙等现象。 从线程请求进入临界区到允许，有次数限制，避免让线程无限等待。 总结为三点: 互斥、前进、有限等待。 Tips: 在非抢占内核系统中进程会一直运行直到中断或退出，故不涉及进程同步问题。 临界区问题的解决方法解决临界区问题，需要通过加锁的方式，类似于当一个线程进入临界区后即上锁，阻止其他线程进入，待运行完成后打开锁允许其他线程进入。 软件实现方法解决临界区问题，主要在于保证资源的互斥访问，以及避免出现饥饿现象。 Peterson算法提供了一个合理的思路: 设置旗标数组flag标记请求进入临界区的线程，设置turn表示可以进入临界区的线程，在进入区进行双重判断，两个线程同时对turn赋值只会有一个保留下来，从而确保资源访问的互斥。而在退出区，对flag旗标进行了false处理，从而保证了”前进”原则，避免了剩余区中的线程持续抢占造成其他线程饥饿。 硬件实现方法Peterson算法是基于软件的实现，而从硬件层面也可以解决此问题，硬件方面的处理主要在于线程修改共享资源时是原子地，即不可被中断。比如机器提供了能够原子执行的指令，那么我们可以通过简单的修改布尔变量来实现互斥，因为加锁的过程是原子的。而对于可能造成饥饿的问题，只需在退出区对等待列表进行一定处理，保证”前进”原则即可。 简单来说，无论硬件还是软件的实现，本质都是通过加锁。只是通过硬件的特性，可以提高效率，同时也简化了临界区的实现难度。 信号量临界区问题为我们解决线程同步提供了一种思路，而在实际使用中，要处理同一个实例有多个资源的情况，我们可以采用一种较为简单的方式——信号量，大多操作系统都提供了信号量的同步工具。 原理简单来说，信号量是某个实例可用资源的计数，初始为该实例可用资源的数量，而每当线程需要使用，则调用wait()方法减少信号量，释放资源时调用signal()方法增加信号量，故信号量为0表示所有资源都在被使用，线程使用资源的请求不被允许。 信号量主要分为计数信号量和二进制信号量，前者主要针对一个实例有多个资源的情况，值域不受限制，而后者信号量仅为0或1，也就是说线程之间访问该资源是互斥的，也可称作互斥锁。 同临界区问题的前提: 必须保证执行信号量操作wait(),signal()是原子地。 以下是信号量的伪代码实现:123456while (true) &#123; waiting(mutex); // 减少信号量(进入区) // 临界区 signal(mutex); // 增加信号量(退出区) // 剩余区&#125; 具体实现由于基于临界区问题，那么信号量在具体实现中也要处理其缺点: 饥饿问题。同时其需要避免忙等问题和死锁问题。 在此之前我们先看一下其基本功能实现。 实现信号量需要维护一个信号量值和一个等待进程链表。当信号量为0时，将请求进入临界区的进程放入等待列表中，并阻塞自己(避免出现频繁循环请求的忙等问题)。待其他临界区退出时，从等待列表中取出并唤醒。以下为实现的伪代码: 1234567891011121314151617181920212223// 信号量定义typedef struct &#123; int value; struct process *list;&#125; semaphore;// 减少信号量void wait(semaphore *mutex) &#123; mutex-&gt;value--; // 减少信号量值 if (mutex-&gt;value &lt; 0) &#123; addToList(list, mutex); // 将该进程添加至等待进程链表 block(); // 阻塞自己等待唤醒 &#125;&#125;// 增加信号量void signal(semaphore *mutex) &#123; mutex-&gt;value++; // 增加信号量 if (mutex-&gt;value &lt;= 0) &#123; process *p = removeFromList(list ,mutex); // 同等待链表中取出一个进程 wakeup(P); // 唤醒等待中的进程 &#125;&#125; 饥饿问题在信号量大于0时从队列中取出哪个进程是需要讨论的问题，选择合适的调度方式很重要。FIFO(先进先出)可以解决，但如果LIFO(后进先出)调度则可能会造成部分进程无限期阻塞，也就是饥饿问题。 忙等问题当进程请求进入临界区而没有被允许时，如果此进程开始在进入区连续循环请求，则会消耗大量性能，浪费了部分CPU时间片。这种加锁方式称为自旋锁，即进程在等待锁时仍然在运行，此方法会造成忙等的性能浪费，但同时也比阻塞-唤醒机制效率更高，避免了阻塞到唤醒的上下文切换。 如果要克服忙等问题，可以在进入区增加当信号量小于0时，进程阻塞自己，进入等待队列；当临界区内的线程执行完毕后，唤醒等待队列中的进程。同时要保证等待队列调度的算法合理性，避免某进程无限期等待。 死锁问题死锁问题就是多个进程无限等待某个事件，而该事件是由这些进程来产生的，这样就会造成”第二十二条军规”中的问题，进程之间互相等待，无法前进。在此不讨论死锁问题，只介绍可能出现的死锁情况。如下图所示: 解决死锁问题主要可以从死锁预防、死锁避免、死锁检测、死锁恢复四个方面入手，后面会专门写文章讲解。 不同处理器的解决方案单个处理器: 单处理器时无须担心并行运算造成的同步问题，所以简单在wait()和signal()中禁止临界区中进程的中断即可。 多处理器: 操作系统对于多处理器调度分为SMP和非SMP的情况(SMP为对称多处理，处理器各自控制各自的调度，而非SMP为某一个处理器作为中控，管理其他处理器的调度)。 非对称多处理: 对于非对称多处理，由于有中央处理器来调度，可以简单使用自旋锁来进行忙等，系统来决策等待锁的进程的调度问题。对称多处理: 对于对称多处理系统，就要自行实现上述的信号量等待列表，以及等待锁时的阻塞——唤醒机制。 经典同步问题涉及到同步问题，有几种经典的问题，主要的有读者——写者问题和哲学家进餐问题，前者关注互斥问题，后者关注死锁问题。 读者——写者问题仅进行读取操作的为读者，而读写操作均需要的为写者。仍然以刚才的买票问题为例，我们不难发现，当同时读取时，不会出现问题，当唯一写入时，也不会出现问题，但是当同时进行读写时，则发生了数据错误问题。 所以读者——写者问题应当保证同一时间写者的唯一性及读者要等待写者完成后再执行。 同时，在实际实现中，要着重处理读者或写者的饥饿问题，读者/写者优先的方案很可能造成对方的饥饿。 哲学家进餐问题哲学家问题是一个经典的死锁问题，n个哲学家围坐在圆桌上，圆桌上放着n支筷子，也就是没人左右都有1支筷子。只有同时拥有两支筷子才能吃饭，吃完饭后会放下筷子。若同一时间每个哲学家都先拿起右手边的筷子再拿起左手的，那么就造成了死锁问题，每个人都在等待左手的筷子。 解决办法多种多样，可以限制哲学家的数量为n-1，也可以要求拿起筷子前判断是否左右手的筷子均空闲。而本质上，解决方法就是死锁的四种解决方法: 死锁预防、死锁避免、死锁检测、死锁恢复。 总结进程/线程同步问题是操作系统在数据共享方面的一大问题，其不仅需要硬件及系统级的实现，同时还需要程序员在开发时避免死锁，同步问题与死锁问题密不可分，后面将会讨论死锁问题。]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>底层</tag>
        <tag>多线程</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创建自己的CocoaPods库并提交指南]]></title>
    <url>%2F2017%2F12%2F30%2F%E5%88%9B%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84CocoaPods%E5%BA%93%E5%B9%B6%E6%8F%90%E4%BA%A4%E6%8C%87%E5%8D%97%2F</url>
    <content type="text"><![CDATA[前言CocoaPods是一款很棒的依赖管理工具，在开发中也经常用它来导入开源第三方库。最近也想把自己的一些库开源并加入CocoaPods中，特总结一下自己制作CocoaPods库的过程。 前提在制作之前，你需要： 掌握CocoaPods的基本使用 掌握Git的简单使用 准备好自己要开源的成品 开始制作下面我们开始制作自己的开源库，以个人的MCScratchImageView为例。 推送至Git仓库(Github)首先需要将你的开源框架上传至远程仓库，比如Github，使用方式不再赘述。记录下你要使用的commit版本对应的SHA值。如下图： 为所选版本打tag在Github自带tag功能在Github上为项目打tag可在release页面，选择创建新tag并按下图所示填写即可。删除tag也同理。由于CocoaPods的版本信息仅支持数字的格式(如1.0.0)，所以版本号请勿带有其他特殊符号和字母。 使用命令行使用命令行进行版本管理较为方便，简单步骤为: 创建本地tag -&gt; 将tag推至远程仓库。 参考如下代码：1234// 创建本地taggit tag -a 1.0.0 0c3b62d -m "Release Edition v1.0.0"// 同步到远程仓库git push origin 1.0.0 具体Tag的使用方式，可以参考使用Git添加tag的方法 制作Podspec描述文件生成Podspec首先在项目主目录输入一下命令pod spec create &lt;你的项目名&gt; 该命令会在目录中生成一个.podspec格式的文件，包含了该框架的详细信息，我们创建CocoaPods库的所有配置都围绕它来完成。 配置Podspec文件使用编辑工具(如SublimeText)打开该podspec文件，文档中已经有详细描述，在此简单说明一下各属性作用： s.name: 框架名称 s.version: 框架最新版本号。这个版本号对应了你Git仓库中某个提交的tag，如果仓库中对应的tag不存在则会提交失败。 s.summary: 框架的概述。s.description: 框架的详细介绍。s.homepage: 框架对应页面，随便写s.license: 框架的开源协议s.author: 框架作者及邮箱，设置方式见注释 s.platform: 这个要按注释写清支持的系统和版本，同时也要保证实际情况，比如Swift3.0最低支持到iOS 8.0，你就不能写最低支持iOS 7.0 s.source: 对应的git源，在Github-&gt;Clone or download-&gt;Clone with HTTPS中 s.source_files: 库的源代码文件。这个是重点，应该包含全部你的库所需的文件。如&quot;s.source_files = MCScratchImageView/*.swift&quot;为MCScratchImageView文件夹内的全部swift代码文件。注意默认为.h和.m文件，需要设置为swift的格式。可以设置多个文件参数。 s.framework: 项目所用到的原生框架，如UIKit Framework s.dependency: 项目需要的其他CocoaPods库，如s.dependency &quot;JSONKit&quot;, &quot;~&gt; 1.4&quot; 验证Podspec文件配置完Podspec文件之后，我们可以预先验证一下文件是否可用。 1pod spec lint &lt;文件名称&gt;.podspec 若提示&lt;文件名&gt; passed validation.，则验证通过。 发布到CocoaPods(Trunk方式)完成了所有的制作之后，我们现在将库发布到CocoaPods。使用了其自带的Trunk工具进行提交。 注册Trunk首先需要将本机注册到trunk1pod trunk register &lt;E-mail&gt; '&lt;用户名&gt;' --description='&lt;设备别名&gt;' 提交注册后，所填写的邮箱将会收到一个验证邮件，确认验证即可。 同时也可以为项目添加其他维护者:1pod trunk add-owner &lt;库名&gt; &lt;其他维护者邮箱&gt; 可以使用pod trunk me来查看当前账户信息。 使用Trunk提交通过配置好的Podspec，我们可以将库提交到CocoaPods上。使用以下命令:1pod trunk push &lt;文件名&gt;.podspec 提交过程会检查你的代码能否正确编译、以及Podspec是否正确配置。若成功将会显示祝贺信息。 查看提交库信息我们可以在提交成功后查看是库是否已经在CocoaPods上，命令如下:123pod search &lt;库名&gt;// 如果查找不到，可以尝试pod search &lt;库名&gt; --simple 如果找不到，可以尝试12pod setuprm ~/Library/Caches/CocoaPods/search_index.json 如果能查看到库信息，则说明上传成功。我们可以看到库的介绍以及所有版本等信息。 删除库的指定版本当上传的库版本号已存在时会发生冲突，不能覆盖。所以我们只能先删除指定版本再重新提交。1pod trunk delete &lt;库名&gt; &lt;版本号&gt; 示例至此，我们已经成功把自己的库提交至CocoaPods，用户可以通过Podfile来使用。下面附一份本人CocoaPods库的Podspec文件以供参考, MCScratchImageView 123456789101112131415Pod::Spec.new do |s|s.name = "MCScratchImageView"s.version = "1.0.0"s.summary = "Custom ImageView like scratch card"s.description = &lt;&lt;-DESCA custom ImageView that is used to cover the surface of other view like a scratch card, user can swipe the mulch to see the view below.DESCs.homepage = "https://github.com/Minecodecraft/MCScratchImageView"s.license = "MIT"s.author = &#123; "Minecode" =&gt; "Minecoder@163.com" &#125;s.platform = :ios, "8.0"s.source = &#123; :git =&gt; "https://github.com/Minecodecraft/MCScratchImageView.git", :tag =&gt; "#&#123;s.version&#125;" &#125;s.source_files = "MCScratchImageView/MCScratchImageView.swift"s.framework = "UIKit"end 如有问题，可以发送邮件至 minecoder@163.com欢迎共同探讨iOS开发问题]]></content>
      <categories>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>CocoaPods</tag>
        <tag>OpenSource</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C开发中Clang的使用]]></title>
    <url>%2F2017%2F12%2F21%2FObjective-C%E5%BC%80%E5%8F%91%E4%B8%ADClang%E7%9A%84%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[在使用Objective-C开发过程中，尤其在了解某些功能的底层实现时，常用到Clang编译器的命令。在此对常用命令做个简单总结。 Clang的简介Clang是一个C、C++、Objective-C和Objective-C++编程语言的编译器前端，其后端为底层虚拟机(LLVM)。是一个GCC的替代品，也是Xcode的首选编译器。 通过Clang，我们可以做什么？ 编译OC代码，这也是它的本职工作。 可以将OC代码转化至C++或汇编代码，从而窥探OC某些特性的底层实现。 在终端快速编译，占用较少内存，同时具有诊断功能。 编译OC代码除了使用Xcode编译工程，我们也可以通过Clang来手动编译。 在Xcode中开发项目时，我们知道，Project-&gt;Targets-&gt;Build Phases-&gt;Compile Sources中对应的文件标记就是指定该文件为ARC/Non-ARC(MRC)。其中ARC对应-fobjc-arc，MRC对应-fno-objc-arc。而刚才说到Clang实际就是LLVM的前端，所以我们在clang中使用同样指令指定编译方式。如下指令： ARC下编译指令clang -fobjc-arc -framework Foundation main.m -o mainMRC下编译指令clang -fno-objc-arc -framework Foundation main.m -o main -framwork [框架名] 对应所使用的框架 -o [文件名] 为输出的可执行文件名 我们在.m文件中输出 “Hello,World”1234int main(int argc, const char * argv[]) &#123;NSLog(@&quot;Hello, World!&quot;);return 0;&#125; 编译OC代码，生成的可执行文件以及终端执行结果如下： 转换为C++代码OC底层实现为C，所以要研究其属性、消息机制、Runtime等特性，就要用到Clang的代码转化。 将OC的.m文件转化为C++源代码clang -rewrite-objc main.m 生成的cpp即为OC的底层实现，接下来就是研究其底层实现的工作了。 转换为汇编代码高级语言最终是要转化为汇编然后转化为01串的，Clang为我们提供了转化为汇编的功能。 将OC的.m文件转化为汇编源代码clang -S main.m 生成的.s即为对应的汇编实现。 其他指令由于其他指令并不常见，不再赘述，列举部分以供查阅。 指令 说明 -E 预编译代码(即处理宏定义) -C 仅编译但不链接(生成.o链接文件) -S 仅编译不汇编(生成.s汇编代码文件) -o 文件名 链接，输出可执行文件 -g 在可执行程序中包含标准调试信息 -I 路径 在头文件的搜索路径列表中添加dir目录 -L 路径 在库文件的搜索路径列表中添加dir目录 相关资料 Clang documentation]]></content>
      <categories>
        <category>iOS技术</category>
      </categories>
      <tags>
        <tag>Clang</tag>
        <tag>Runtime</tag>
        <tag>Objective-C</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[探究Objective-C属性关键字]]></title>
    <url>%2F2017%2F12%2F19%2F%E6%8E%A2%E7%A9%B6Objective-C%E5%B1%9E%E6%80%A7%E5%85%B3%E9%94%AE%E5%AD%97%2F</url>
    <content type="text"><![CDATA[在使用Objective-C时，频繁用到属性关键字。我们应该理解每种属性的意义，并了解一些偏底层的实现，故在此对OC的属性关键字做个浅析。 基础概念：ivar、getter、setter在C语言中，我们通常是直接操作成员变量。而在Objective-C中，使用了“属性”这一概念来封装对象中的数据，OC对象会把需要的数据保存为各种实例变量，同时通过“存取方法”(Access Method)来进行访问，也就是常说的getter和setter。 所以，ivar是对象的各种实例变量，getter用于获取变量的值，setter用于写入变量的值。 我们来看一个标准的ivar+getter+setter样板代码：1234567891011121314@interface Person: NSObject&#123; // ivar声明 @private NSString *_myName;&#125;// getter方法- (NSString *)myName &#123; return _myName;&#125;// setter方法- (void)setMyName:(NSString *)newName &#123; _myName = newName;&#125; 可以看到，这样的组合方式造成了代码的臃肿，大大降低了开发效率和可读性，实际开发中使用ivar+getter+setter的情况并不常见，这就要引入@synthesize和@property这个关键字。 @synthesize这个属性已经很少见到了，它是属于MRC和32bit时代的产物。@synthesize属性用来合成一个属性，变量名如果没有显式声明则默认添加一个下划线的前缀(_变量名)。当然也可以手动声明变量名并建立与@property的关系。 为了加深理解，我们看一下以下代码，它的逻辑为：手动声明ivar，使用property声明存取方法，使用@synthesize建立ivar和property的关系。12345678910111213@interface SubClass ()&#123; // 声明ivar NSString *_myName;&#125;// 声明属性(并合成getter+setter)@property (nonatomic, copy) NSString* myName;@end@implementation SubClass// 建立myName属性与_myName成员变量的关系@synthesize myName = _myName;@end 可以看出@synthesize和@property各自负责的工作，虽然这些工作已经由编译器帮我们做了，但是理解这一概念还是很重要的。 现在我们知道了省略@synthesize声明实际上是因为LLVM的Clang为在ARC模式下会自动生成@synthesize声明，但是这仅限于64位OC运行时中，当使用32位系统时，我们必须要手动声明，否则会报错。我们可以设置NS_BUILD_32_LIKE_64宏来解决这个问题。 @dynamic相对于@synthesize，@dynamic告诉编译器该属性的getter和setter由程序员自行实现，编译器不再自动生成。在运行时执行过程中如果找不到对应存取方法，则会报错。这便是Runtime中的动态绑定。 同时，使用了@dynamic修饰则必须动态生成方法实现，没有@dynamic myName = _myName;的语法，也就是说我们没有办法静态的建立getter/setter并访问下划线前缀的ivar。对应的解决方法是消息转发和动态方法解析，本文不过多讨论。 @property本质上来说，@property实际上是告知编译器为你的ivar生成getter和setter，并不生成ivar，要理解这一点。但是由于@synthesize无须再手动声明，所以我们使用@property后实际上是声明了ivar+getter+setter的标准模板。 Runtime下的定义我们首先反编译为cpp代码，有关反编译的内容请见Objective-C开发中Clang的使用。 可以发现property在OC运行时中是objc_property_t类型的，定义如下：123456typedef struct objc_property *objc_property_t;struct property_t &#123; const char *name; const char *attributes;&#125;; property结构体有name和attributes两个成员变量，而attributes则是property的属性定义，我们看一下它的定义：12345/// Defines a property attributetypedef struct &#123; const char *name; /**&lt; The name of the attribute */ const char *value; /**&lt; The value of the attribute (usually empty) */&#125; objc_property_attribute_t; 我们可以通过以下方法获取对应变量：12345678// 获取所有属性列表class_copyPropertyList// 获取属性名property_getName// 获取属性描述字符串property_getAttributes// 获取所有属性列表property_copyAttributeList 可以看到，每一个attribute对应一种属性修饰符，property所定义的属性就包含其中。对应关系如下 属性修饰符类型 name value 属性类型 T 属性类型名 内存管理 C(copy) &amp;(strong/retain) W(weak) R(readonly) 空 自定义getter/setter G(getter) S(setter) 方法名 原子/非原子类型 N(nonatomic) 空(atomic) 空 ivar名称 V 变量名称 比如我们分别定义一个对象类型、标量、以及id类型的属性来看一下 属性定义 attributes描述 @property char charDefault; Tc,V_charDefault @property (nonatomic, copy) NSString *myString; T@”NSString”,C,N,V_myString @property(nonatomic, readonly, retain) id idVar; T@,R,&amp;,V_idVar 注意：注意描述符中的V_ivar名称，此描述符是基于64bit系统的，因为会自动合成ivar，如果是32bit系统则不会有下划线，前文已做解释。 Runtime下的实现了解了属性在运行时系统下的定义，我们现在探究一下其的实现。运行时中有ivar、method、class、object等概念，其中@property就涉及到了ivar和method(get方法和set方法)，具体如何实现呢，我们通过反编译来一探究竟。 在OC中，所有对象都可以认为是id类型，id类型定义为下：123typedef struct objc_object &#123; Class isa;&#125; *id; 而id类型就是指向Class类型的指针，那么Class又是什么呢？12345678910111213141516struct objc_class &#123; Class isa OBJC_ISA_AVAILABILITY; #if !__OBJC2__ Class super_class OBJC2_UNAVAILABLE; const char *name OBJC2_UNAVAILABLE; long version OBJC2_UNAVAILABLE; long info OBJC2_UNAVAILABLE; long instance_size OBJC2_UNAVAILABLE; struct objc_ivar_list *ivars OBJC2_UNAVAILABLE; struct objc_method_list **methodLists OBJC2_UNAVAILABLE; struct objc_cache *cache OBJC2_UNAVAILABLE; struct objc_protocol_list *protocols OBJC2_UNAVAILABLE; #endif&#125; OBJC2_UNAVAILABLE; 现在我们大致了解了OC中对象的实现原理。OC中所有对象都可以认为是id类型，而id又是指向Class的指针，Class类型实际是objc_class结构体，其定义了OC对象的基本信息。 更多Runtime的内容在此不再赘述，我们来看一下属性涉及到的类型：objc_ivar_list和objc_method_list：1234567891011struct objc_ivar &#123; char *ivar_name; char *ivar_type; int ivar_offset; int space;&#125;;struct objc_ivar_list &#123; int ivar_count; int space; struct objc_ivar ivar_list[1];&#125; 在此我们看到了ivar的真面目，它包含了名称、类型、基地址偏移、内存空间。同样，objc_method_list定义如下：1234567891011121314struct objc_method_list &#123; struct objc_method_list *obsolete; int method_count; #ifdef __LP64__ int space; #endif /* variable length structure */ struct objc_method method_list[1];&#125;;struct objc_method &#123; SEL method_name; char *method_types; /* a string representing argument/return types */ IMP method_imp;&#125;; 所以，当在类中创建一个属性时。Runtime做了以下事情： 创建该属性，设置其objc_ivar，通过偏移量和内存占用就可以方便获取。 生成其getter和setter。详情请查阅objc中方法的实现(SEL,IMP)。 将属性的ivar添加到类的ivar_list中，作为类的成员变量存在。 将getter和setter加入类的method_list中。之后可以通过直接调用或者点语法来使用。 将属性的描述添加到类的属性描述列表中。 属性的获取为了记录属性，有以下几个变量：ivar_list: 记录成员变量的描述method_list: 记录该变量getter和setter的描述prop_list: 记录属性的描述OBJC_IVAR_$类名_$属性名称: 记录属性相对对象地址的偏移地址(重要) 其中，记录变量的偏移地址很重要。我们来看一下实现：12345678910// 生成一个SubClass类型，包含一个属性@interface SubClass ()@property (nonatomic, strong) NSMutableArray* array;@end// 在该类的实现中创建一个方法@implementation SubClass- (void)testArrayMethod &#123; self.array = [NSMutableArray array];&#125;@end 反编译代码，我们查看一下它是如何赋值的：1234567891011121314// 属性的定义extern "C" unsigned long OBJC_IVAR_$_SubClass$_array;struct SubClass_IMPL &#123; struct NSObject_IMPL NSObject_IVARS; NSMutableArray *_array;&#125;;// 赋值(已经去掉了复杂的类型转换代码)static void _I_SubClass_testArrayMethod(SubClass * self, SEL _cmd) &#123; (objc_msgSend)(self, sel_registerName("setArray:"), (objc_getClass("NSMutableArray"), sel_registerName("array")));&#125;// 属性的setter方法static void _I_SubClass_setArray_(SubClass * self, SEL _cmd, NSMutableArray *array) &#123; *(self + OBJC_IVAR_$_SubClass$_array) = array;&#125; 我们可以看到，属性的偏移地址命名为OBJC_IVAR_$类名_$属性名称，点语法本质上是调用了setter，而setter中确定属性对应ivar的内存地址则是通过 对象地址+偏移量 来寻址，即*(self + OBJC_IVAR_$_SubClass$_array)。 @Property的属性修饰符谈完@property的底层实现，再看一下属性修饰符。此处仅讨论@property的属性修饰符，对于ARC的所有权修饰符(__strong,__weak,__unsafe_unretained,__autorealesing)会专门写一篇文章讨论。 属性符作用及区别 属性 内容 readwrite 属性可读可写，生成getter+setter，默认属性 readonly 属性只读，只生成getter nonatomic 非原子属性，提高性能但线程不安全 atomic 原子属性，线程安全但可能降低性能 MRC模式下 assign 直接赋值，不增加引用计数 retain 持有对象，引用计数+1 copy 生成并持有一个新对象，并深拷贝对象的值 ARC模式下 strong 强引用，持有对象，引用计数+1，相当于MRC的retain weak 弱引用，不持有对象，不增加引用计数，相当于MRC的assign，但在对象销毁后会置为nil copy 深拷贝，同MRC的copy unsafe_unretained 无须内存管理的对象，相当于MRC的assign，对象销毁后不会置nil，可能造成野指针。(iOS 4之后基本废弃，使用assign替代) 同时，根据LLVM文档所述，ARC模式下依旧可以使用MRC修饰符，编译器会自动转换。assign对应unsafe_unretained，retain对应strong。 原子属性atomic原子属性(atomic)通过加锁来实现访问/赋值的线程安全，但atomic只是保证了getter和setter的线程安全，并没有保证整个对象是线程安全的。比如线程A在读数据，而线程BCD在写数据，虽然BCD并不能同时写，但A读到的数据却是BCD某个时间写入的，无法保证线程安全。同样的，对于objectAtIndex:等非getter/setter方法，则不是线程安全的。 weak的使用场景及与assign的区别首先，weak与assign都表示了一种“非持有关系”(nonowning relationship)，也成弱引用，在使用时不会增加被引用变量的引用计数。而weak在引用的对象被销毁后会被指向nil，保证了安全，相反assign不会被置nil，成为野指针。其次，对于标量(基础数据类型:int,double，以及OC中使用宏定义的数据类型:CGFloat,NSInteger)，只能使用assign。weak只能用于对象，assign可用于对象和标量。 copy的使用场景及注意事项使用copy修饰的对象在赋值的时候创建对象的副本，也成深拷贝。实际则是调用了copy方法。支持copy方法要遵守NSCopying协议，实现copyWithZone:方法来生成并持有对象的副本。同时，还有mutableCopy用于实现对于可变对象的深拷贝，如NSMutableArray。当我们想复制字符串的值而非直接引用该字符串时，我们就应该深拷贝一份，否则会出现修改原对象值的情况。NSArray、NSDictionary，以及我们自己的类同理。但是，对于@property的copy修饰符，只是调用了copy方法，所以只能生成不可变对象。对于如下代码：12345@property (nonatomic, copy) NSMutableArray *mutableArray;/* ... */NSMutableArray *anotherMutableArray = [NSMutableArray arrayWithObjects:@1,@2,nil];self.mutableArray = anotherMutableArray;[self.mutableArray removeObjectAtIndex:0]; 会发生崩溃。原因在于copy生成了不可变对象，导致removeObjectAtIndex:方法报错。所以，对于可变对象，不要使用copy属性修饰符，而是调用mutableCopy方法。 相关资料 Objective-C Runtime Programming Guide - Declared Properties]]></content>
      <categories>
        <category>iOS技术</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
        <tag>Objective-C</tag>
        <tag>底层</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS/OS X的Tagged Pointer]]></title>
    <url>%2F2017%2F12%2F15%2FiOS%3AOS%20X%E7%9A%84Tagged%20Pointer%2F</url>
    <content type="text"><![CDATA[Tagged Pointer是存在于字符串、NSNumber、NSDate等重复性高且较小的对象中的一种优化方式，用于解决重复性较高的类型在64位操作系统内存的内部碎片问题。 背景在创建讨论Tagged Pointer之前，我们先认识一下它执行以下代码: 1234567891011121314__weak NSNumber *weakNumber;__weak NSString *weakString;__weak NSDate *weakDate;int num = 123;@autoreleasepool &#123; weakNumber = [NSNumber numberWithInt:num]; weakString = [NSString stringWithFormat:@&quot;string%d&quot;, num]; weakDate = [NSDate dateWithTimeIntervalSince1970:0];&#125;NSLog(@&quot;WeakNumber is %@&quot;, weakNumber);NSLog(@&quot;WeakString is %@&quot;, weakString);NSLog(@&quot;WeakDate is %@&quot;, weakDate); 运行结果为: 123WeakNumber is 123WeakString is string123WeakDate is Thu Jan 1 08:00:00 1970 这样的结果与想象中可能不同，我们设置weakNumber/weakString/weakDate变量为弱引用，而在NSNumber/NSString/NSDate创建的代码部分设置了自动释放，那么当运行到输出部分的代码时，数字和字符串变量理应已经释放掉了，那么结果自然应该输出nil，然而事实是他们并没有。为什么会这样？下面我们来介绍苹果在推出64位系统后为了节省内存和提高效率而引入的Tagged Pointer。 简介在iPhone 5s推出后，处理器步入了64位架构时代，而我们知道，64位系统中变量所占字节也会随之变大，如32位系统中的int为4字节，而64位系统下是8字节。虽然值域也随之变大，但是很多情况下，增加的值域对于数字、日期、短字符串来说并不需要。造成的内部碎片问题如下图，大多数情况下64位系统增加了32位的内存浪费: 那么能否优化这一内存浪费问题呢？可以注意到，虽然我们每个数字对象都占用8字节，但大家实际能用到的数字可能仅仅几位，大数计算的情况很少。那么，以较低的内存消耗预先保存一些常见数字，而对于不常见的再动态创建8字节的变量的方案，就会更加节省内存，以及创建对象的性能消耗。 Tagged Pointer知道了存在的问题，我们现在则介绍一下Tagged Pointer。它就是将大部分常用的字符串、数字对象、日期预先保存，而其不再按照64位系统的8字节大小，当我们创建的对象内容命中了Tagged Pointer预先存储的内容时，我们的对象指针会变成Tagged Pointer，指向指定的内存。我们可以看如下的例子: 123456int num = 123;NSString *str1 = [NSString stringWithUTF8String:&quot;String123&quot;];NSString *str2 = [NSString stringWithFormat:@&quot;String%d&quot;, num];NSLog(@&quot;%p&quot;, str1);NSLog(@&quot;%p&quot;, str2); 打印的地址相同，证明两者指向了同一地址。 那么如何实现将这些对象不按照8字节存储的呢？Tagged Pointer将一个对象按32位保存(4字节)，而后对其绑定一个同样是4字节的Tag，从而可以方便定位它。这样一个Tag+对象总共为8字节，与32位系统中对象指针+对象内容大小相当。至于为什么对象要按4字节保存而不是由数据大小而定，则是为了避免产生外部碎片。内存图如下所示: isa和引用计数现在再谈一些与Tagged Pointer有关的问题。看了其内存图后，我们知道它不是真正意义上的OC对象，那么其isa指针也就无法正常使用了。我们可以通过object_getClass()方法来获取真实对象，该对象打印结果为NSTaggedPointerString、__NSTaggedDate、__NSCFNumber。 同时，Tagged Pointer的引用计数是无穷大的，可以尝试如下代码打印: 12// ARC模式下可以使用CFGetRetainCount函数获取引用计数NSLog(@&quot;Retain count: %ld&quot;, CFGetRetainCount((__bridge CFTypeRef)(str1))); 结果是无穷大。所以对于类似如下的题目: 1234567NSString *str1 = [NSString stringWithUTF8String:&quot;String123&quot;];[str1 retain];NSString *str2 = str1;[str2 release];[str1 retain];/* ......... */NSLog(@&quot;Retain count: %lu&quot;, [str1 retainCount]); 无论题目中如何引用和释放，最终，其引用计数都会因为它是Tagged Pointer而是无穷大。 常量与Tagged Pointer区别当我们如下方式定义常量str3时： 1234int num = 123;NSString *str1 = [NSString stringWithUTF8String:&quot;String123&quot;];NSString *str1 = [NSString stringWithUTF8String:&quot;String%d&quot;, num];NSString *str2 = @&quot;String123&quot;; 我们会发现str3和其余两个的地址并不一样，这是为什么呢？ 我们要知道，常量不是Tagged Pointer，因为它是在运行时之前就导入的，存在于数据段内。而其余两个对象是在运行时生成的，所以才可以通过Tagged Pointer这一机制进行优化。 相关资料 mikeash.com - Friday Q&amp;A 2015-07-31: Tagged Pointer Strings mikeash.com - Friday Q&amp;A 2012-07-27: Let’s Build Tagged Pointers]]></content>
      <categories>
        <category>iOS技术</category>
      </categories>
      <tags>
        <tag>Runtime</tag>
        <tag>底层</tag>
        <tag>性能优化</tag>
        <tag>Objecitve-C</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP五层模型消息解/封装仿真]]></title>
    <url>%2F2017%2F12%2F09%2FTCP%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B%E6%B6%88%E6%81%AF%E8%A7%A3-%E5%B0%81%E8%A3%85%E4%BB%BF%E7%9C%9F%2F</url>
    <content type="text"><![CDATA[消息封/解装仿真功能要求按照TCP五层模型仿真消息在两台主机之间的通信过程。 在发送端模拟数据从高层到低层的封装过程，在接收端模拟数据从低层到高层的解封装过程。 按照每层的功能对数据填加报头，并显示每一层得到的封/解装格式。 传输层和网络层的封装格式参考TCP/IP的相应各层协议格式。 网络层的IP报文需要模拟报文分段和重组的过程。 数据链路层帧格式参考局域网的MAC帧格式。 物理层显示为0或1比特串。 Socket编程简介Socket是网络文件描述符。在基于Socket的编程技术中，用户不直接访问发送和接收包的网络接口设备，而是建立一个中间文件描述符来处理编程接口到网络的操作。简单来说，Socket就是我们常说的“套接字”。本段只介绍了本实验需要设计的知识，更多Socket用法可Google一下。 Socket包含的内容 一个特殊的通信域，比如一个网络连接 一个特殊的通信类型，比如流或者数据报 一个特殊的协议，比如TCP或者UDP 其中，可以实现面向连接和无连接的Socket 面向连接的Socket 面向无连接的Socket 模拟TCP 语言 Objective-C + C 平台 Mac OSX 工具 XCode (LLVM) 最终效果 运行逻辑本实验模拟了TCP五层模型中的消息解/封装仿真，建立在现有网络的基础上，使用Socket进行通信，使用了面向连接的Socket。除了两台机器相互通信之外，我们也可以将服务端绑定到网卡端口，使用客户端与服务端在本机相互通信。 由服务端绑定端口并侦听客户端消息。而后客户端连接服务端，并相互发送消息。 服务端(Server)首先，服务器绑定端口，并侦听客户端连接请求，当客户端连接后进行消息侦听和发送。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465- (void)bindSocketWithPort:(NSInteger)port &#123; // 创建Socket地址 struct sockaddr_in server_addr; // socket地址 server_addr.sin_len = sizeof(struct sockaddr_in); // 设置地址结构体大小 server_addr.sin_family = AF_INET; // AF_INET地址簇 server_addr.sin_port = htons((short)port); // 设置端口 server_addr.sin_addr.s_addr = htonl(INADDR_ANY); // 服务器地址 // 创建Socket int server_socket = socket(AF_INET, SOCK_STREAM, 0); // 创建Socket if (server_socket == -1) &#123; [self showMessageWithMsg:@&quot;创建Socket失败&quot;]; return; &#125; int reuse = 1; int sockOpt = setsockopt(server_socket, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, sizeof(reuse)); if (sockOpt == -1) &#123; [self showMessageWithMsg:@&quot;重设Socket失败&quot;]; return; &#125; // 绑定Socket // 将创建的Socket绑定到本地IP和端口,用于侦听客户端请求 int bind_result = bind(server_socket, (struct sockaddr *)&amp;server_addr, sizeof(server_addr)); if (bind_result == -1) &#123; [self showMessageWithMsg:@&quot;绑定Socket失败&quot;]; return; &#125; // 侦听客户端消息 if (listen(server_socket, 5) == -1) &#123; [self showMessageWithMsg:@&quot;开启侦听失败&quot;]; return; &#125; // 获取客户端端口信息 struct sockaddr_in client_address; socklen_t address_len; int client_socket = accept(server_socket, (struct sockaddr *)&amp;client_address, &amp;address_len); if (client_socket == -1) &#123; [self showMessageWithMsg:@&quot;客户端握手失败&quot;]; return; &#125; char recv_msg[RECV_BUFFER_SIZE]; char reply_msg[REPLY_BUFFER_SIZE]; while (YES) &#123; bzero(recv_msg, RECV_BUFFER_SIZE); bzero(reply_msg, REPLY_BUFFER_SIZE); long byteLen = recv(client_socket, recv_msg, RECV_BUFFER_SIZE, 0); recv_msg[byteLen] = &apos;\0&apos;; // 添加消息结尾 NSMutableString *msgStr = [NSMutableString stringWithFormat:@&quot;%s&quot;, recv_msg]; [self clearCurrentMsg]; strcpy(recv_msg, [[self reciveFromClient:msgStr] UTF8String]); if (strcmp(recv_msg, &quot;&quot;) != 0) &#123; strcpy(reply_msg, &quot;服务端消息:收到&quot;); strcat(reply_msg, recv_msg); send(client_socket, reply_msg, REPLY_BUFFER_SIZE, 0); &#125; &#125;&#125; 客户端(Client)首先，客户端要和服务端建立连接。调用socket的方法顺序为：socket() -&gt; connect()12345678910111213141516171819202122232425262728293031323334353637- (void)bindSocketWithIP:(NSString *)ipStr andPort:(NSInteger)port &#123; // 创建Socket地址 struct sockaddr_in server_addr; // 创建Socket地址 server_addr.sin_len = sizeof(struct sockaddr_in); // 设置结构体长度 server_addr.sin_family = AF_INET; // AF_INET地址簇 server_addr.sin_port = htons((short)port); // 设置端口 server_addr.sin_addr.s_addr = htonl(INADDR_ANY); // 服务器地址 // 创建Socket int server_socket = socket(AF_INET, SOCK_STREAM, 0); if (server_socket == -1) &#123; [self showMessageWithMsg:@&quot;创建Socket失败&quot;]; return; &#125; else &#123; // 保存Socket self.server_socket = server_socket; // 保存port self.port_num = (short)port; [self showMessageWithMsg:@&quot;创建Socket成功&quot;]; [NSThread sleepForTimeInterval:0.3]; &#125; int connect_result = connect(server_socket, (struct sockaddr *)&amp;server_addr, sizeof(struct sockaddr_in)); if (connect_result == -1) &#123; [self showMessageWithMsg:@&quot;连接主机失败&quot;]; return; &#125; else &#123; [self showMessageWithMsg:@&quot;连接主机成功,等待发送消息...&quot;]; [NSThread sleepForTimeInterval:0.3]; &#125; // 连接成功后的操作 [self didConnected];&#125; 连接成功后，双方互相发送和接收消息send() -&gt; recv()123456789101112131415161718192021222324252627- (void)sendMsgAction &#123; NSMutableString *msg = [NSMutableString stringWithFormat:@&quot;%@&quot;,self.msgField.stringValue]; char recv_msg[RECV_BUFFER_SIZE]; char send_msg[REPLY_BUFFER_SIZE]; // 发送消息，并接收服务器回信 bzero(recv_msg, RECV_BUFFER_SIZE); bzero(send_msg, REPLY_BUFFER_SIZE); // 向服务端通过socket发消息 NSMutableString *resStr = [self appLayerWithString:msg]; strcpy(send_msg, resStr.UTF8String); long send_result = send(self.server_socket, send_msg, REPLY_BUFFER_SIZE, 0); if (send_result == -1) &#123; [self showMessageWithMsg:@&quot;消息发送失败&quot;]; return; &#125; else &#123; [self showMessageWithMsg:@&quot;消息发送成功&quot;]; [NSThread sleepForTimeInterval:0.3]; &#125; // 接收服务端消息 long recv_result = recv(self.server_socket, recv_msg, RECV_BUFFER_SIZE, 0); [self reciveFromServer:[NSString stringWithUTF8String:recv_msg]]; &#125; 报头编码各层在传递给下一层之前，要对数据进行封装，增加对应的报头。具体代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130#pragma mark - 五层传输协议// 模拟网络层对数据的包装- (NSMutableString *)appLayerWithString:(NSMutableString *)str &#123; NSMutableString *resStr = [NSMutableString stringWithFormat:@&quot;AppHeader#%@&quot;, str]; dispatch_async(dispatch_get_main_queue(), ^&#123; self.appLayer.stringValue = [resStr copy]; &#125;); [NSThread sleepForTimeInterval:0.3]; return [self transferLayerWithString:resStr];&#125;// 模拟传输层对数据的包装- (NSMutableString *)transferLayerWithString:(NSMutableString *)str &#123; NSMutableString *resStr = [NSMutableString string]; // 添加源端口 16位(0-15) [resStr appendFormat:@&quot;0000000011111111&quot;]; // 添加目的端口 16位(16-31) [resStr appendFormat:@&quot;%@&quot;, [self intToBinary:self.port_num]]; // 添加序列编号 32位 [resStr appendFormat:@&quot;00000000000000000000000000001011&quot;]; // 添加确认帧 32位 [resStr appendFormat:@&quot;00000000000000000000000011111011&quot;]; // 添加报头长度 [resStr appendFormat:@&quot;0101&quot;]; // 添加保留长度 [resStr appendFormat:@&quot;000000&quot;]; // 添加FLag [resStr appendFormat:@&quot;000000&quot;]; // 添加窗口大小 [resStr appendFormat:@&quot;0000000000000111&quot;]; // 添加确认值 [resStr appendFormat:@&quot;0101010101010010&quot;]; // 添加UrgentPointer [resStr appendFormat:@&quot;0000000000001111&quot;]; // 添加Header结尾 [resStr appendFormat:@&quot;#%@&quot;, str]; dispatch_async(dispatch_get_main_queue(), ^&#123; self.transLayer.stringValue = [resStr copy]; &#125;); [NSThread sleepForTimeInterval:0.3]; return [self networkLayerWith:resStr];&#125;// 模拟网络层对数据的包装- (NSMutableString *)networkLayerWith:(NSMutableString *)str &#123; NSMutableString *resStr = [NSMutableString string]; // 添加VER [resStr appendFormat:@&quot;0100&quot;]; // 添加HLEN [resStr appendFormat:@&quot;1111&quot;]; // 添加Service [resStr appendFormat:@&quot;00000000&quot;]; // 添加totalLength [resStr appendFormat:@&quot;0101010101010101&quot;]; // 添加Identification [resStr appendFormat:@&quot;0000000000000000&quot;]; // 添加Flag [resStr appendFormat:@&quot;000&quot;]; // 添加FragmentationOffset [resStr appendFormat:@&quot;0000000000000&quot;]; // 添加TTL [resStr appendFormat:@&quot;00000000&quot;]; // 添加Protocol [resStr appendFormat:@&quot;00000000&quot;]; // 添加HeaderChecksum [resStr appendFormat:@&quot;0000000000000000&quot;]; // 添加SourIPAddress [resStr appendFormat:@&quot;00000000000000000000000000000000&quot;]; // 添加DestinationIPAddress [resStr appendFormat:@&quot;00000000000000000000000000000000&quot;]; // 添加Header结尾 [resStr appendFormat:@&quot;#%@&quot;, str]; dispatch_async(dispatch_get_main_queue(), ^&#123; self.networkLayer.stringValue = [resStr copy]; &#125;); [NSThread sleepForTimeInterval:0.3]; return [self dlinkLayerWithString:resStr];&#125;// 模拟链路层对数据的包装- (NSMutableString *)dlinkLayerWithString:(NSMutableString *)str &#123; NSMutableString *resStr1 = [NSMutableString string]; // 添加FrameFlag1 [resStr1 appendFormat:@&quot;00001111&quot;]; // 添加FrameAdd [resStr1 appendFormat:@&quot;11101011&quot;]; // 添加FrameControl [resStr1 appendFormat:@&quot;01111000&quot;]; NSMutableString *resStr2 = [NSMutableString string]; // 添加FrameFCS [resStr2 appendFormat:@&quot;00001111&quot;]; // 添加FrameFlag2 [resStr2 appendFormat:@&quot;11101011&quot;]; // 合成帧 NSMutableString *resStr = [NSMutableString stringWithFormat:@&quot;%@#%@#%@&quot;, resStr1, str, resStr2]; dispatch_async(dispatch_get_main_queue(), ^&#123; self.dlinkLayer.stringValue = [resStr copy]; &#125;); [NSThread sleepForTimeInterval:0.3]; return [self phyLayerWithString:resStr];&#125;// 模拟物理层对数据的包装- (NSMutableString *)phyLayerWithString:(NSMutableString *)str &#123; NSMutableString *resStr = [NSMutableString stringWithFormat:@&quot;PhysicsHeader#%@&quot;, str]; dispatch_async(dispatch_get_main_queue(), ^&#123; self.phyLayer.stringValue = [resStr copy]; &#125;); [NSThread sleepForTimeInterval:0.3]; return resStr;&#125; 其他细节1、在定义Socket地址端口时，要注意端口值类型，若使用htons，则需要转换为short类型(16位)。server_addr.sin_port = htons((short)port); 本文源代码：Github: https://github.com/Minecodecraft/TCP-IP-Model-Simulation原文地址：Minecode’s Blog: TCP五层模型消息解/封装仿真]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>TCP/IP</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用iOS ARKit制作AR传送门]]></title>
    <url>%2F2017%2F11%2F11%2F%E5%88%A9%E7%94%A8iOS%20ARKit%E5%88%B6%E4%BD%9CAR%E4%BC%A0%E9%80%81%E9%97%A8%2F</url>
    <content type="text"><![CDATA[前言苹果推出ARKit半年了，开发者对其兴趣有增无减，AR产业也借苹果谷歌等厂商的努力得到了快速发展。作为广大iOS开发者的一员，我也加入了学习AR的队伍中。得益于SceneKit优越的性能和封装，ARKit的开发也如鱼得水，如果你有SceneKit开发经验，那么短时间开发出一款很酷的AR应用不是难事。这次，我们尝试使用ARKit来制作一个传送门（或者说哆啦A梦的任意门） 项目效果： 前期准备制作前，我们需要准备好任意门中的3D模型，以及任意门中的天空盒贴图。在这里我使用了大学的钟塔模型，使用了Cinema4D制作，SceneKit支持dae或obj格式的模型，导入后可以转换成SceneKit对应的scn格式。天空盒贴图是什么？游戏中对于一些有边界地图，想要创造远距离场景的视觉效果，就可以采用将天空盒包裹当前真实场景的方法，如CS。 项目的配置1. Info.plist的配置AR需要使用摄像头权限，在Info.plis中添加“Privacy - Camera Usage Description”键值 2. 界面设置显示AR摄像机，需要使用AR场景控件，拖ARKit Scene View至故事版，同时我们需要放置按钮以及检测到平面的提示Label 开始Coding配置ARSceneViewARKit追踪需要一个AR世界追踪配置项，可以通过实例化ARWorldTrackingConfiguration类来实现（早期是ARWorldTrackingSessionConfiguration）。我们想要追踪水平面，从而放置传送门模型，所以在此将其planeDetection设置为追踪水平面。12345678910111213141516// 用于配置AR世界追踪// The Configuration of World Trackinglet configuration = ARWorldTrackingConfiguration()var planeAnchor: ARPlaneAnchor?override func viewDidLoad() &#123; super.viewDidLoad() // 设置AR平面检测类型 // set the plane detecing type of world tracking configuration.planeDetection = .horizontal sceneView.debugOptions = [ARSCNDebugOptions.showFeaturePoints] sceneView.session.run(configuration) sceneView.delegate = self sceneView.automaticallyUpdatesLighting = true&#125; 获取追踪平面我们在上一步设置了水平面追踪，在这里进行设置。ARKit提供了识别水平面的代理方法，在ARSCNViewDelegate中。ARKit会不停追踪平面，当追踪到新平面(plane)时，会向该平面上添加锚点(anchor)。代理中为我们提供了这一代理方法。对于追踪到的平面，会添加ARAnchor，而如果检测到的是用户设置的检测平面(我们之前设置的planeDetection)，将会放置ARPlaneAnchor。所以我们直接判断该anchor的类型即可。123456789101112// MARK: - ARSCNViewDelegate implementionextension ARViewController: ARSCNViewDelegate &#123; func renderer(_ renderer: SCNSceneRenderer, didAdd node: SCNNode, for anchor: ARAnchor) &#123; // 如果检测到的是水平面，那么就是我们需要的，所以在此判断是否为水平面 guard anchor is ARPlaneAnchor else &#123;return&#125; self.planeAnchor = anchor as? ARPlaneAnchor // 处理逻辑 &#125;&#125; 获取平面的位置上一步我们获取了水平面对应的ARPlaneAnchor，而此时我们需要获取该平面在AR世界中的位置信息。方法就是使用transform属性，该属性返回一个matrix_float4x4结构体。了解过计算机图形学的应该知道，图形的变换矩阵正是这样的一个结构。我们可以通过修改transform中的对应位置值，就可以对图形进行自由变换。而我们现在只需要获取他的坐标信息，也就对应着第3行的前三个值。同时，在SceneKit中三维坐标使用的是SCNVector3。所以我们在此扩展SCNVector3以便复用。123456789extension SCNVector3 &#123; init (withTransform transform: matrix_float4x4) &#123; self.x = transform.columns.3.x self.y = transform.columns.3.y self.z = transform.columns.3.z &#125;&#125; 设置模型在创建模型之前，我们先创建一个模型的集合，拓展名为scnassets。接下来我们创建一个天空盒，并将想要往其中放置的模型也一并放置。天空盒的材质设置为我们准备好的天空盒贴图。但是现在有一个问题，如何才能使这个天空盒在外面不可见而在里面可见呢？答案就是，使用渲染顺序，渲染顺序在前的优先渲染，渲染顺序决定了模型之间的关系，我们可以通过优先渲染前面的透明遮罩平面来来后面的内容“被透明”。所以在每一个平面上添加一个名为“mask”的平面，大小与父平面相同即可，厚度尽可能小就好。如下图，具体请见工程源文件。 使天空盒从外面不可见首先我们先添加模型，代码比较简单，在此不赘述。12345guard let portalScene = SCNScene(named: "Model.scnassets/tjgc.scn") else &#123;return&#125;let portalNode = portalScene.rootNode.childNode(withName: "tjgc", recursively: false)!let newVector3 = SCNVector3.init(withTransform: transform)portalNode.position = SCNVector3.init(newVector3.x, newVector3.y, newVector3.z-1)sceneView.scene.rootNode.addChildNode(portalNode) 接下来就是实现的重点：如何可以让天空盒从外面不可见？刚才谈到了，我们可以通过让一个渲染顺序更靠前的透明平面遮挡来实现让某个平面“被透明”的效果，而这样也可以使另一个方向观察不受影响。在SceneKit中，渲染顺序对应renderingOrder属性，数值越小越优先渲染。123let child = portalNode.childNode(withName: nodeName, recursively: true)child?.geometry?.firstMaterial?.diffuse.contents = UIImage(named: "Model.scnassets/\(imageName).png")child?.renderingOrder = 200 如上面代码所示，我们只需要把需要处理的节点取出并设置渲染顺序即可。 重置AR场景很多时候我们想要重置AR追踪，并将现有节点全部移除。可以通过如下代码实现：12345678910111213141516func reset() &#123; // 清除节点之前先停止AR会话，否则会crash // pause ar session before remove node, or will be crash self.sceneView.session.pause() self.sceneView.scene.rootNode.enumerateChildNodes &#123; (node, _) in node.removeFromParentNode() &#125; self.planeAnchor = nil self.addButton.isEnabled = false // 使用重置配置启动AR会话，场景将会被重置 // Run AR session with reset options, then session will be reset self.sceneView.session.run(configuration, options: [.resetTracking, .removeExistingAnchors])&#125; 具体代码见Github项目： https://github.com/Minecodecraft/ARDoor 如果有问题，欢迎评论区留言]]></content>
      <categories>
        <category>iOS开发</category>
      </categories>
      <tags>
        <tag>ARKit</tag>
        <tag>SceneKit</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结构体的自引用及相互引用]]></title>
    <url>%2F2017%2F10%2F01%2F%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E8%87%AA%E5%BC%95%E7%94%A8%E5%8F%8A%E7%9B%B8%E4%BA%92%E5%BC%95%E7%94%A8%2F</url>
    <content type="text"><![CDATA[简述在用C来实现数据结构以及部分算法时，经常用到结构体，比如实现树以及树的子节点时，就需要该结构体包含自身类型的成员变量。而最近在研究OC的匿名函数实现时，也涉及到了类似需求。同时，两个结构体之间相互引用也经常遇到问题。故简单总结一下C语言结构体的自引用语法。 示例我们以二叉树的节点为例来看一下自引用：12345struct binary_tree &#123; int data ; // Data area struct binary_tree * left; struct binary_tree * right;&#125;; 在树中，我们需要保存其左右子树，所以需要引用自身。 结构体自引用不使用typedef如果不适用typedef，那么此时我们需要使用struct [名称]来调用。但如果按下面的调用方式12345struct binary_tree &#123; int data; struct binary_tree left; struct binary_tree right;&#125;; 则会导致在分配内存的时候循环分配，此时编译器会计算left和right的成员变量并为之分配内存，从而导致嵌套死循环。12345struct binary_tree &#123; int data; struct binary_tree * left; struct binary_tree * right;&#125;; 所以后者是正确的，left和right在分配时是以结构体指针的形式来分配内存的。而意义上我们就是为了将其指向另一个binary_tree，所以这样是复合逻辑的。 使用typedef使用typedef可以为结构体设置别名，但是要注意的是，typdef的语法为typedef [原类型] [别名];所以在结构体声明之前，别名是未定义的。所以我们在内部需要使用其原类型来定义成员变量。12345typedef struct binary_tree &#123; int data; struct binary_tree * left; struct binary_tree * right;&#125;BinTREE; 结构体相互引用同文件内使用不完整类型通过不完整类型语法来实现相互引用123456789struct s_a &#123; int id; struct s_b *B_Ptr;&#125;;struct s_b &#123; int id; A *A_Ptr;&#125;; 使用前向声明123456789101112typedef struct s_a A;typedef struct s_b B;struct s_a &#123; int id; B *B_Ptr;&#125;;struct s_b &#123; int id; A *A_Ptr;&#125;; 不同文件内对于不同文件，主要有两点需要注意的。 头文件重复包含问题 结构体的声明问题 而前者通过宏定义解决123456#ifndef __FILENAME_H#define __FILENAME_H// 代码#endif 后者通过上述的“前向声明”或“不完整类型即可解决”。]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[iOS的多线程]]></title>
    <url>%2F2017%2F08%2F01%2FiOS%E7%9A%84%E5%A4%9A%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[在iOS开发中我们经常涉及到多线程的问题，多线程广泛用于耗时操作、并发、单例等方面。故总结一下多线程的相关知识及用法(pthread NSThread GCD NSOperation)。 基本概念进程: 操作系统运行中的任务通常对应一个进程，当进程进入内存后，及变成一个进程。在iOS中每个启动的APP即为一个进程。进程之间独立且受保护。线程: 进程内部每个顺序执行流就是一个线程，一个进程可以有多个线程。任务: 一种抽象的概念，表示需要执行的工作。 多线程原理:单个处理器同一时间只能处理一个线程，通过快速在多个线程之间轮换执行，使得宏观上具有多个线程同时执行的效果。多线程具体内容见操作系统原理。 优缺点多线程的优点不言而喻，比如可以提高程序执行效率、提高资源利用率、并在执行完任务后自动销毁。但多线程的使用依然要适度，多线程存在一些缺点。 首先，开启多线程需要一定的内存开销: 根据官方文档说明，主要线程占用空间1MB(其实实际只占用了512k)，次要线程每开启一个占用512kb(我们所创建的线程即是次要线程)。每次线程创建耗时90ms。所以，过度使用多线程反而会使性能降低。其次，我们知道CPU是通过线程的轮换而实现多线程的，那么每次切换线程都会在上下文切换时产生性能开销。最后，线程间通信也是一个需要考虑的问题，即生产者–消费者问题，增加了数据共享的难度。 iOS系统多线程原则及方案iOS多线程原则首先，我们先解释一个概念: UI线程/主线程在开发中常提到”UI线程”或”主线程”，iOS系统在程序运行之后会默认开启一个线程来作为主线程，其一般用于刷新UI界面，处理UI事件。我们在没有指定任务在其他线程执行时，也是直接在主线程执行的。所有UI更新操作都应该在主线程进行。因为iOS的UI控件默认都是线程不安全的，这是出于性能的考虑。如果在其他线程更新，有一定几率出现问题。耗时操作不应放在主线程执行。正是因为UI更新都是在主线程完成的，那么如果我们将耗时操作放在主线程，将会阻塞主线程，导致页面卡住，降低用户体验。 iOS的多线程技术方案iOS系统存在着4中多线程技术方案: pthread、NSThread、GCD、NSOperation。(Swift中名称略有不同) 多线程方案 语言 ARC下的内存管理 使用频率 pthread C 程序员手动管理 ★☆☆☆☆ NSThread OC/Swift(Thread) 程序员手动管理 ★★☆☆☆ GCD C/OC/Swift ARC自动管理(多数情况) ★★★★★ NSOperation OC/Swift ARC自动管理 ★★★★☆ Tips: 主要以OC讲解，在Swift 3.0+中名称与用法略有不同。(如NSThread -&gt; Thread, dispatch_XXX -&gt; DispatchQueue) 多线程的使用pthread (POSIX threads)这个是最老盘的多线程方案了，在类Unix操作系统（Unix、Linux、Mac OS X等）中，都使用pthread作为操作系统的线程。iOS开发中基本不会用到(如果你频繁使用pthread，那么受我一拜…)。 使用pthread需要导入头文件: #import &lt;pthread.h&gt; 或 #import &lt;pthread/pthread.h&gt; 使用方法：1234567891011121314151617181920212223242526272829303132333435- (void)pthreadTest &#123; /* 创建线程使用pthread_create函数 函数原型: pthread_create(pthread_t _Nullable *restrict _Nonnull, const pthread_attr_t *restrict _Nullable, void * _Nullable (* _Nonnull)(void * _Nullable), void *restrict _Nullable) 参数： 1) 线程标识符指针，pthread_t 2) 线程属性(注意空地址为NULL,空对象是nil) 3) 要执行的函数指针 4) 执行函数的参数 返回值： - 创建成功，返回0 - 创建失败，返回出错代码 */ pthread_t id = NULL; NSString *paraStr = @&quot;Hello World&quot;; int res = pthread_create(&amp;id, NULL, taskFunction, (__bridge void *)(paraStr)); if (res == 0) &#123; NSLog(@&quot;线程创建完成&quot;); &#125; else &#123; NSLog(@&quot;线程创建失败 错误:%d&quot;, res); &#125; pthread_detach(id);&#125;void *taskFunction(void *params) &#123; NSString *str = (__bridge NSString *)(params); NSLog(@&quot;Thread:%@ -&gt; Message:%@&quot;, [NSThread currentThread], str); return NULL;&#125; 补充: __bridge在OC与C进行混编时，会遇到OC对象与C变量之间的转换问题。在OC中id为万能指针，而C中void *为万能指针。在id类型或对象类型变量赋值给void *类型或反向赋值时，需要进行特定转换。 为什么要进行转换呢？这主要是因为面向对象涉及到的内存管理问题，OC中对象由MRC、ARC来进行管理，而其不能管理C变量，那么在转换时会造成内存管理的冲突。__bridge即告知编译器，该变量内存由程序员自行进行管理。 同时桥接转换还有另外两种类型: __bridge_retained和__bridge_transfer，前者为是被赋值的变量持有该对象，后者为被赋值的变量持有该对象并使赋值的对象释放其持有。由于涉及到引用计数知识，在此不赘述。如果只是为了单纯赋值，那么使用__bridge即可。 NSThread由于pthread过于底层，复杂性不利于开发。故苹果封装成了NSThread，这是一款较轻量的多线程实现方案，使用面向对象语法，其生命周期需要程序员自行管理。在MacOS和iOS都可使用。(Swift中为Thread)。NSThread类代表线程，创建新线程也就是创建NSThread对象。 创建线程NSThread创建分动态方法和静态方法两种:12345678910/// 创建并启动新线程+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(id)argument; /// 仅创建新线程，返回NSThread对象，并未启动线程- (id)initWithTarget:(id)target selector:(SEL)selector object:(id)argument; /* - SEL 所要执行的方法 - target selector消息的接收对象 - argument 方法唯一参数，或nil */ 可以发现，前者与后者并没有太大区别，只是前者不会返回NSThread对象，创建线程后立即启动，而后者只是创建一个NSThread对象并返回，需要手动调用start方法启动线程。 同时还有一类隐式创建线程的方法:1- (void)performSelectorInBackground:(SEL)aSelector withObject:(id)arg; performXxx 这一类方法，在创建线程时也是使用的NSThread。 线程的状态首先我们来看一下线程执行的状态: 前面提到，多线程的原理是CPU轮换调度多个线程。所以某线程在某一时刻不一定正在被执行。简单解释一下线程的几个状态:就绪: 线程准备就绪可以被执行时，会放入可调度线程池，供CPU调用。阻塞: 当线程的正常执行被组止，比如调用了sleep方法或线程在等待同步锁，那么线程会进入阻塞状态。注意，此”阻塞”与常说的”耗时操作阻塞UI线程”并非同一概念，后者只是占用UI线程资源导致UI操作无法正常执行。死亡: 当线程任务执行完毕后会自动销毁。同时当遇到异常时，或我们自行使用exit方法终止线程，线程都会死亡，不再可用。 NSThread提供的API 优先级: 线程为我们提供了线程优先级属性以干预其执行，对应threadPriority属性，范围是0.0~1.0，权值越高优先级越高。但注意，该权值仅为线程在调度时的优先权重，并非绝对优先。 线程是否执行完毕: 对应executing, finished两个属性，前者在线程正在执行时为YES，后者在执行完毕时为YES。 线程取消标记: NSThread提供了cancel实例方法，对应的有cancelled属性，但是注意该方法并非真正终止该线程，而是将cancelled标记为YES，而后由程序员手动判断cancelled属性并作出决策。如果需要强制结束，应使用exit方法。 线程睡眠如果需要让当前线程睡眠一段时间，可以调用sleepXXX 方法阻塞线程。 1234// 阻塞一段时间+ (void)sleepForTimeInterval:(NSTimeInterval)ti;// 阻塞到指定时间+ (void)sleepUntilDate:(NSDate *)date; 被阻塞的线程是暂时不可执行的，所以不会进入可调度线程池。在其阻塞结束后，会进入可调度线程池并在CPU时间片到来时开始执行。 终止线程前面提到，线程的终止有三种情况: 线程执行体执行完成，线程正常结束。 线程执行过程出现错误，异常退出。 手动调用exit方法终止了线程。 提一个小问题: 当主线程结束时，其他线程会受影响吗？ 答案是不会，当线程被启动，其本质上与主线程是相同地位的，并不会受到其影响。 线程安全问题线程安全问题一直是多线程需要特别注意的，解决线程同步问题一般采用加锁的方式。iOS提供了很多种锁的方案，本质上为同步锁、互斥锁两种。 互斥锁: 发现其他线程正在执行锁定代码后，线程会进入休眠(阻塞)，待加锁的线程执行完毕打开锁时，会唤醒该休眠线程。自旋锁: 发现其他线程正在执行锁定代码后，线程会采用死循环方式轮询，直到锁被打开。简单来说，自旋锁由于采用了死循环轮询，会比互斥锁有更高的效率，但同时也造成更大的性能消耗。 OC对象的atomic属性修饰符就是使用了自旋锁，自旋锁同一时间可以有一个写者或多个读者，但是不能同时既有读者又有写者。 iOS常用的加锁方案有: @synchronized, NSLock, NSCondition。加锁方式和区别将在其他文章介绍。 几乎所有UIKit提供的类都是线程不安全的，所有包含’Mutable’的类都是线程不安全的。 死锁当一组进程中的每个进程都在等待一个事件，而这一事件只能由这一组进程的另一进程引起，那么这组进程就处于死锁状态。死锁问题是操作系统的经典问题，详见操作系统原理。 死锁发生的必要条件: 互斥: 至少有一个资源必须处于非共享模式，如果另一线程申请该资源，那么申请线程必须等待该资源被释放为止。如互斥锁这一情况。 占有并等待: 该线程等待某资源，而该资源为其他线程所有。 非抢占: 资源不能被抢占，只能在线程完成任务后自动释放。 循环等待: 一组等待线程T1~Tn,其中Ti的资源被Ti+1所占有，造成循环等待。 GCD (Grand Central Dispatch)NSThread是一款较为轻量的多线程实现，程序员需要自行控制同步和并发，较为复杂。iOS在4.0之后提供了GCD来实现多线程。其弱化了单个线程的概念，强调队列和任务两大核心概念。 队列: GCD为用户封装出了串行队列和并发队列两种队列。队列负责管理开发者提交的任务，采用FIFO(先进先出)的方式。串行队列提交的后一个任务只能等到前一个任务执行结束后才能开始执行；并发队列的任务按FIFO机制并发启动并执行多个任务。任务: 开发者提交给队列的工作单元。 GCD的实现机制GCD底层维护了一个可重用线程池，当线程结束后，系统并不第一时间销毁该线程，而是将其放入线程池中待用，若一段时间后仍未使用，则销毁。 串行队列底层的线程池只需要一个线程，因此只提供一个线程用来执行任务。而并发队列需要多个线程来实现并发，所以线程池中维护了多个线程。 GCD使用步骤我们可以使用系统自带的队列，获取方法如下 12345// 根据指令的优先级、额外旗标获取全局并发队列。// 优先级id为DISPATCH_QUEUE_PRIORITY_XXXdispatch_queue_t dispatch_get_global_queue(long identifier, unsigned long flags);// 获取主线程所关联的队列(串行队列)dispatch_queue_t dispatch_get_main_queue(void); 同时，我们也可以自行创建队列，但是ARC并不能管理自行创建的队列，所以需要我们自行管理内存:123456789/* - 根据指定字符串标签创建队列 - label 为字符串标签 - attr 控制队列是串行队列还是并发队列，前者为DISPATCH_QUEUE_SERIAL，后者为DISPATCH_QUEUE_CONCURRENT。 */dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr);// 需要自行释放内存dispatch_release() 同步/异步提交任务GCD对于任务的提交，提供了同步/异步两种方式，同时支持Block和函数指针两种形式的任务。 1234567891011121314151617/// 异步// Blockvoid dispatch_async(dispatch_queue_t queue, dispatch_block_t block);// 函数void dispatch_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work);/// 同步// Blockvoid dispatch_sync(dispatch_queue_t queue, dispatch_block_t block);// 函数void dispatch_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work);/// 延时任务// Blockvoid dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block);// 函数void dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *context, dispatch_function_t work); 同时，还提供了多次执行任务和单次执行任务，后者可以用于单例模式。123456789101112/// 多次执行// Blockvoid dispatch_apply(size_t iterations, dispatch_queue_t queue, void (^block)(size_t));// 函数void dispatch_apply_f(size_t iterations, dispatch_queue_t queue, void *context, void (*work)(void *, size_t));/// 单次执行/* 需要提供一个dispatch_once_t的指针最为标记 */// Blockvoid dispatch_once(dispatch_once_t *predicate, dispatch_block_t block);// 函数void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function); 其他常见API队列优先级设置队列优先级与目标队列一致，实现对队列优先级的控制以及多个串行队列的有序执行。1234567891011121314/* - 参数1: 需要被设置优先级的队列。 - 参数2: 设置优先级时的目标队列。 */void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue);// 情况1: 目标队列为不同优先级的队列，被设置的队列将拥有和目标队列相同的优先级dispatch_queue_t serialDispatchQueue = dispatch_queue_create(&quot;serialDispatchQueue&quot;, NULL);dispatch_queue_t backgroundDispatchQueue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_BACKGROUND, 0);dispatch_set_target_queue(serialDispatchQueue, backgroundDispatchQueue);// 情况2: 目标队列为串行队列，而多个串行队列设置其为目标队列后将互相串行，同一时间只有其中一个队列执行串行任务。 调度组(Dispatch Group)针对希望在追加到Dispatch Queue队列中的任务全部完成后执行某一特定任务的情况，提供了Dispatch Group这一特性。创建线程组后，可以向其中追加任务，当所有任务全部完成时，会执行通知任务，通知任务的具体内容由程序员设置。 1234567891011121314// 创建Dispatch Groupdispatch_group_t group = dispatch_group_create();// 获取一个并发队列dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRORITY_DEFAULT, 0);// 追加两个任务dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;No.1&quot;); &#125;);dispatch_group_async(group, queue, ^&#123;NSLog(@&quot;No.2&quot;); &#125;);//设置完成时的任务dispatch_group_notify(group, dispatch_get_main_queue(), ^&#123;NSLog(@&quot;All task done&quot;)&#125;);// Dispatch Group需要手动释放内存dispatch_release(group) Dispatch Barrier为了解决线程安全问题，我们可以将读取处理放入并发队列中，将写入处理放入串行队列中，同时还要保证在没有读取操作时写入。我们可以通过队列优先级和调度组结合实现，但是这样过于复杂。GCD提供了dispatch_barrier_async函数来实现这一点。 dispatch_barrier_async函数会等待追加到并发队列中的任务全部完成后才将自己的处理追加到并发队列中，但此时并发队列仅运行该任务，待该任务执行完后，并发队列恢复正常继续并发执行。 123456789101112// 创建并发队列dispatch_queue_t queue = dispatch_queue_create(&quot;barrierTest&quot;, DISPATCH_QUEUE_CONCURRENT);// 读取操作dispatch_async(queue, readingBlock1);dispatch_async(queue, readingBlock2);dispatch_async(queue, readingBlock3);// 写入操作dispatch_barrier_async(queue, writingBlock1);// 读取操作dispatch_async(queue, readingBlock4);dispatch_async(queue, readingBlock5); 线程的挂起/恢复 可以将线程暂时挂起，后面再进行恢复执行。但仅限于还未执行的任务，已执行的和正在执行的任务不受影响。12345// 挂起线程dispatch_suspend(queue);// 恢复线程dispatch_resume(queue); Dispatch Semaphore(信号量)控制为了精确控制并行处理，GCD提供了信号量12345// 生成Dispatch Semaphore并指定信号量dispatch_semaphore_t semaphore = dispatch_semaphore_create(1);// 等待信号量大于等于1dispatch_semaphore_wait(semaphore, DISPATCH_TIME_FOREVER); NSOperation除了使用GCD之外，iOS还提供了NSOperation/NSOperationQueue这一多线程实现方式。 实现机制NSOperation代表一个多线程任务。NSOperationQueue代表一个FIFO的队列，其底部维护一个线程池，会按照先入先出的顺序执行提交给队列的NSOperation任务。 使用步骤使用NSOperationQueue较为简单，其负责管理、执行所有NSOperation，开发者能够将注意力更多的放在任务上而非队列的使用上。其主要提供了以下API:123456789101112// 添加到队列中- (void)addOperation:(NSOperation *)op;// 添加并阻塞当前线程至所有任务完成- (void)addOperations:(NSArray&lt;NSOperation *&gt; *)ops waitUntilFinished:(BOOL)wait;// 取消所有操作- (void)cancelAllOperations;// 设置NSOperationQueue队列最大支持的并发线程数量@property NSInteger maxConcurrentOperationCount;// 设置和返回是是否暂停调度当前正在排队的任务，需要使用KVC设置@property(getter=isSuspended) BOOL suspended; NSOperation使用NSOperation一般不直接使用，而是创建其子类来使用。继承NSOperation需要重写其main方法，该方法的方法体用于NSOperationQueue来执行任务。 而默认为我们提供了NSInvocationOperation和NSBlockOperation两种子类，分别对应了SEL和Block两种任务提交方式。12345// NSInvocationOperation- (instancetype)initWithTarget:(id)target selector:(SEL)sel object:(id)arg;// NSBlockOperation+ (instancetype)blockOperationWithBlock:(void (^)(void))block; 总结本文主要总结iOS开发中的多线程概念、技术方案以及简单实用，具体的使用方式不再赘述。开发中常用到GCD和NSOperation，而前者在功能丰富性和复杂性上也许有着更好的均衡。 同时本文还涉及到了线程安全、线程中锁的技术方案、线程的使用规则等问题，有兴趣的可以进一步研究。 相关资料 iOS多线程编程指南: Threading Programming Guide iOS并行编程指南: Concurrency Programming Guide]]></content>
      <categories>
        <category>iOS技术</category>
      </categories>
      <tags>
        <tag>GCD</tag>
        <tag>多线程</tag>
        <tag>iOS技术</tag>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Objective-C协议遵守NSObject协议的原因]]></title>
    <url>%2F2017%2F03%2F24%2FObjective-C%E5%8D%8F%E8%AE%AE%E9%81%B5%E5%AE%88NSObject%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8E%9F%E5%9B%A0%2F</url>
    <content type="text"><![CDATA[今天将用OC写的框架迁移至Swift时，发现OC写的协议都遵守了NSObject，而在Swift中没有此协议。所以记录一下这个问题的原因： 在Objective-C 2.0之后，方法修饰符有@required和@optional(新增)，也就是说增加了可选方法。对应的，也就需要在调用代理方法之前判断其是否被实现。也就是我们熟悉的如下写法: 123if (self.delegate != nil &amp;&amp; [self.delegate respondsToSelector:@selector(protocolFunc)]) &#123;[self.delegate protocolFunc];&#125; NSObject的协议主要定义了以下几个常见方法: - (BOOL)isKindOfClass:(Class)aClass; - (BOOL)isMemberOfClass:(Class)aClass; - (BOOL)conformsToProtocol:(Protocol *)aProtocol; - (BOOL)respondsToSelector:(SEL)aSelector; etc… 这就是为什么我们需要继承NSObject。而Swift语言为我们提供了可选项，保证了调用的安全性，所以我们可以按如下方法使用: 1234567891011121314151617181920// 定义协议@objc protocol MCTestViewDelegate: class &#123;@objc func testViewNeedsOperate()@objc optional func testViewDidUpdate()&#125;/* ... */// 判断是否遵守协议并调用if let delegate = testView is MCTestViewDelegate &#123;delegate.testViewNeedsOperate()&#125;// 判断代理对象是否实现该代理方法if (delegate as? MCTestViewDelegate)?.testViewDidUpdate != nil &#123;// 处理...&#125;// 一句话实现(delegate as? MCTestViewDelegate)?.testViewDidUpdate?() 通过可选项的判断，即可轻松判断方法/协议是否实现，减少了代码量。]]></content>
      <categories>
        <category>iOS技术</category>
      </categories>
      <tags>
        <tag>Objective-C</tag>
        <tag>Swift</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[使用Git添加Tag的方法]]></title>
    <url>%2F2016%2F10%2F21%2F%E4%BD%BF%E7%94%A8Git%E6%B7%BB%E5%8A%A0Tag%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[简述作为版本管理工具，Git可以对某个版本打上标签(tag)，表示本版本为发行版。在发布软件，以及使用CocoaPods创建依赖库等情况时，需要对其版本使用标签注释。故简单总结一下添加tag的方式。 使用Git命令查看标签打印所有标签1git tag` 打印符合检索条件的标签1git tag -l &lt;版本号&gt; 如 git tag -l 1.*.* 为搜索一级版本为1的版本 查看对应标签状态1git checkout &lt;版本号&gt; 创建本地标签创建轻量标签轻量标签指向一个发行版的分支，其只是一个像某commit的引用，不存储名称时间戳及标签说明等信息。定义方法如下1git tag &lt;版本号&gt;-light 创建带附注标签相对于轻量标签，附注标签是一个独立的标签对象，包含了名称时间戳以及标签备注等信息，同时指向对应的commit。定义方法如下1git tag -a &lt;版本号&gt; -m "&lt;备注信息&gt;" 同时我们也可以像特定的commit添加标签，使用该commit对应的SHA值即可1git tag -a &lt;版本号&gt; &lt;SHA值&gt; -m "&lt;备注信息&gt;" 比如 git tag -a 1.0.0 0c3b62d -m &quot;Release Edition v1.0.0&quot; 就是为SHA为0c3b62d的这次提交打了1.0发行版的tag 删除本地标签1git tag -d &lt;版本号&gt; 将本地标签提交到远程仓库前面所提到的创建标签，只是将标签添加到了本地的版本管理，我们需要在创建之后将本地标签同步到远程仓库，如Github。 推送所有标签1git push origin --tags 推送指定版本的标签1git push origin &lt;版本号&gt; 删除远程仓库的标签同创建本地标签一样，删除了本地标签之后也要同时删除远程仓库的标签。 新版本Git (&gt; v1.7.0)1git push origin --delete &lt;版本号&gt; 新旧版本通用方法旧版本Git并没有提供直接删除的方法，而我们可以通过将一个空标签替换现有标签来实现删除标签，即如下命令1git push origin :refs/tags/&lt;版本号&gt; 补充：使用Github添加标签Github为我们提供了在页面上进行编辑发行版本的方式，如下图所示： 在Github上为项目打tag可在release页面，选择创建新tag并按下图所示填写即可。删除tag也同理。母。 总结最后总结一下常用命令，方便查阅。 123456789101112131415161718192021222324252627282930/// 查看标签// 打印所有标签git tag// 打印符合检索条件的标签git tag -l 1.*.*// 查看对应标签状态git checkout 1.0.0/// 创建标签(本地)// 创建轻量标签git tag 1.0.0-light// 创建带备注标签(推荐)git tag -a 1.0.0 -m "这是备注信息"// 针对特定commit版本SHA创建标签git tag -a 1.0.0 0c3b62d -m "这是备注信息"/// 删除标签(本地)git tag -d 1.0.0/// 将本地标签发布到远程仓库// 发送所有git push origin --tags// 指定版本发送git push origin 1.0.0/// 删除远程仓库对应标签// Git版本 &gt; V1.7.0git push origin --delete 1.0.0// 旧版本Gitgit push origin :refs/tags/1.0.0]]></content>
      <categories>
        <category>开源框架</category>
      </categories>
      <tags>
        <tag>Github</tag>
        <tag>CocoaPods</tag>
        <tag>OpenSource</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CALayer的寄宿图]]></title>
    <url>%2F2016%2F09%2F01%2FCALayer%E7%9A%84%E5%AF%84%E5%AE%BF%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[寄宿图我们都知道，视图可以导入图片，并设置其拉伸模式、放大比例之类。而图层也可以导入图片，CALayer提供了寄宿图的概念来实现这一点。简单来说，寄宿图就是图层之中包含的图。 CALayer的contents属性在设置图层图片时，需要给contents赋值。其定义如下：@property(nullable, strong) id contents;可以看到，它是一个id类型的对象，但是这是为了兼容OSX开发中CoreAnimation、AppKit中的CGImage和NSImage两种类型而设置。对于UIKit的UIImage并不支持，设置了无法识别的对象是不能显示的，所以使用UIImage需要调用下述的转换方法：- (nullable CGImageRef)CGImage由于转换的是CGImageRef，我们知道C类型是不受ARC管理的，所以需要进行类型桥接。最终就是如下效果：layer.contents = (__bridge id)image.CGImage; contents相关属性设置了寄宿图，我们还需要对其进行参数调整。图层在样式和动画方面提供了比视图更多的选择： contentGravity // 拉伸模式 contentsScale // 像素比例 maskToBounds // 是否裁切 contentsRect // 显示区域 contentsCenter // 拉伸区域 contentsGravity当我们为content设置了图片后，图片默认是会拉伸至图层大小的，而如同视图的contetMode，图层为我们提供了contentGravity属性。@property(copy) NSString *contentsGravity;它是NSString类型，可选的常量值为kCAGravity**,具体如下 kCAGravityCenter kCAGravityTop kCAGravityBottom kCAGravityLeft kCAGravityRight kCAGravityTopLeft kCAGravityTopRight kCAGravityBottomLeft kCAGravityBottomRight kCAGravityResize kCAGravityResizeAspect kCAGravityResizeAspectFill 对于图片被拉伸的问题，我们处理之后如下: contentsScale由于苹果设备多采用了Retina屏幕，屏幕的实际分辨率(手机像素)和设计分辨率(视图的点)之间存在着区别。比如对于iPhone 6，视图大小为375×677(单位:点)，但实际像素为750×1334(单位:像素)，在界面开发时并无大碍，而对于图片素材，我们有时候不希望高分屏与图片的像素绘制比例为1:1，为了不让图片换算成视图大小后太小，就要设置实际缩放比，从而让高分屏用多个像素显示图片1个像素的内容。苹果为我们提供了contentsScale属性来设置。 比如当我们设置contentsScale为1.0，即屏幕每一个点绘制图片的1个像素。而contentsScale为2.0时，屏幕每一个点绘制图片的2个像素。显示效果如下: Tips: 需要注意，缩放只有在图片适配模式不是kCAGravityResize*(拉伸)模式时才有效。 maskToBounds这个属性对应视图的clipToBounds属性。默认情况下视图和图层都允许子视图和子图层的绘制范围超出自己的边界。但是很多情况下我们并不想要这个效果，很多样式都需要裁切子图层。效果如下: contentsRectcontentsRect用来指定内容显示的区域，比如显示图片的某个局部细节。注意数值是比例大小(0.0~1.0)，而非视图大小。其只是设置显示区域，而非裁剪图片，内存中保存的依旧是整个图片，如果要处理图片应使用Core Graphic。 contentsCenterUIImage提供了resizableImageWithCapInsets方法来配置图片的拉伸，而在图层中可以通过设置ccontentsCenter属性来设置一个可拉伸区域，从而保证图片在收到拉伸时局部不变形。 我们选择一张聊天气泡的照片，然后编写如下代码来测试:123456789101112- (void)viewDidLoad &#123;[super viewDidLoad];self.view.backgroundColor = [UIColor lightGrayColor];UIImage *image = [UIImage imageNamed:@&quot;bubble&quot;];self.layerView1.layer.contents = (__bridge id)image.CGImage;self.layerView2.layer.contents = (__bridge id)image.CGImage;self.layerView2.layer.contentsCenter = CGRectMake(0.75, 0.75, 0.1, 0.1);&#125; 原图及裁切效果为： 通过Core Graphic绘制CALayer除了通过Core Animation框架的属性来设置外，还可以直接通过Core Graphic来绘制。 UIView的显示机制当视图在屏幕上出现时，它会检测-(void)rawRect:是否被实现(该方法无默认实现)，如果实现了则为视图创建一个寄宿图，其大小等于视图大小×contentsScale。(若不实现该方法则不会创建，进而优化性能)。 -(void)drawRect:是视图的方法而不是图层的，图层提供了图层方法的代理，可由视图通过实现代理方法完成绘图。-(void)drawRect:不能手动调用，需要调用-(void)setNeedsDisplay来通知重绘。 调用-(void)setNeedsDisplay后会出发代理方法-(void)displayLayer:(CALayer )layer和-(void)drawLayer:(CALayer )layer inContext:(CGContextRef)ctx。 (注：如果两种方法同时存在，则只会调用后者)。]]></content>
      <categories>
        <category>iOS技术</category>
      </categories>
      <tags>
        <tag>iOS动画</tag>
        <tag>Core Animation</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[树状数组的几种模型]]></title>
    <url>%2F2016%2F08%2F13%2F%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84%E7%9A%84%E5%87%A0%E7%A7%8D%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[树状数组基本定义：树状数组是利用二分的思想使得查询和修改的复杂度都为log(n)的数据结构，主要用于查询数组前缀和、区间和并且经常更改数据。 数据结构思想：如上图，2的k次方的位置存放1一直到 2^k 这些数的和，然后再不断二分。具体实现可以用二进制解释，也就是例如XXX100中储存的是XXX000~XXX100这一个区间的所有数 基本操作：而要实现这一点，就要求一个二进制数的最低位1，这个可以用lowbit操作实现：一个二进制数x对其进行x&amp;(-x)的操作，就可以保留其最低位的1，而讲其他全部位全清零所以一个数加上自己的lowbit，就到了上一级包含自己的区间，例如110(6)加上10变成了1000(8)，因为1000对应的0~1000同样，减去自己的lowbit就相当于去尾。 模型1：改点求点求段123456789101112131415161718192021//设M为最大数的上限，treeray存树状数组void add(int k,int num)//像某个位置添加的操作&#123; while(k&lt;=M)//防止上界溢出 &#123; treeray[k]+=num; k+=k&amp;(-k);//不断加上lowbit来向上更新包含自己的区间 &#125; return;&#125;int read(int k)//读取以某个位置为终点的前缀和&#123; int sum=0; while(k)//一定要注意树状数组不能储存0这个位置 &#123; sum+=treeray[k]; k-=k&amp;(-k);//不断减lowbit来加上前面区间的和 &#125; return sum;&#125; 模型2：改段求点当需要改段求点时，利用树状数组方便求前缀和的特性，我们采用记录变化量的技巧，就可以使得一个数的前缀和变成他之前所有的变化量，便可得到这个数本身。在树状数组中，每个数初始化为0，然后每个位置记录它与左边的差值，如图所示： 123456//add与read函数同上//当在a与b间全部加上c时add(a,c);add(b+1,c);//当要得到k的值时read(k); 模型3：改段求段当需要改段求段时，与前一种类型的区别是，需要求某一点“真正的”前缀和。考虑前一种方法，只知道该点本身与前面所有变化量的总和，却不知道这些变化是从哪里开始的，无法方便地求出前缀和。我们先假设这个点之前所有数都与这个点相等，这样必然会多出前面的一些变化值变化长度这么多，那么我们再用一个树状数组，其中在每一个变化点记录变化值变化长度，那么最终算某个点的和，只需要再减去这个树状数组的在该点的值，如图所示：12345678910111213141516171819202122232425262728293031323334353637int A[],B[]; //两个树状数组void tadd(int a[],int x,int c)&#123; while(x&lt;=N) &#123; a[x] += c; x += lowbit(x); &#125; return;&#125;int tread(int a[],int x)&#123; int sum=0; while(x&gt;0) &#123; sum += a[x]; x -= lowbit(x); &#125; return sum;&#125;void update(int a,int b,int c)&#123; tadd(A,a,c); tadd(A,b+1,-c); tadd(B,a,c*(a-1)); //叠加前缀变化量 tadd(B,b+1,-c*b); return;&#125;int querry(int a,int b)&#123; int sum1=tread(A,a-1)*(a-1)-tread(B,a-1); int sum2=tread(A,b)*b-tread(B,b); return sum2-sum1;&#125; 模型4：多维树状数组（以二维为例）多维树状数组只需把多维的每一维度分别当作一维树状数组即可，那么N维的某一点的前缀和，其实就是，各个维度的前缀和分别映射到其他维度的前缀和所以这里给出二维树状数组的代码实现，具体可以见下面的例题POJ1195：12345678910111213141516void tadd(int i,int j,int c)&#123; for(int x=i;x&lt;=N;x+=lowbit(x)) for(int y=j;y&lt;=N;y+=lowbit(y)) //一定要注意这里不能再直接用传入的形参j了，因为每次循环都要使之成为刚传入的值 base[x][y]+=c; return;&#125;int tread(int i,int j)&#123; int sum=0; for(int x=i;x&gt;0;x-=lowbit(x)) for(int y=j;y&gt;0;y-=lowbit(y)) sum+=base[x][y]; return sum;&#125; 注意提示1.树状数组中一定不能有0元，如果题目中有要注意处理。通常是整体数据加1，这样后同时也要注意变化后的数据上限2.树状数组可以用来求逆序数，实现方法使让数字成为树状数组的元素，比某个数小的数有多少就是这个数在数组中的前缀和]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
        <tag>ACM</tag>
        <tag>算法</tag>
      </tags>
  </entry>
</search>
